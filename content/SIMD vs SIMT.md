关于 SIMD 和 SIMT，基础概念都很清楚了，SIMT 相比于 SIMD 提供了更大的“灵活性”。但是真正的问题在于：这种灵活性到底意味着什么？

SIMT 这种灵活性的意味着每个线程都可以进行 **独立访存** 和 **独立控制流** ，这两点都是 SIMD 难以进行的。独立访存意味着每个线程都可以随机化的访问地址，牺牲的是 SIMD 整体访存的效率。独立控制流意味着不同 thread 可以执行不同的代码，牺牲的是执行效率（本质是掩码分支执行）。

另外我希望讨论一下 SIMT 中多线程的范围，这其实有两个层面。在 CUDA 编程模型层面，可以看作多线程的范围是一个 kernel。在一个 kernel 中，我们用 `(block_id, thread_id)` 来指定某个 thread 的访存行为和控制流。而在硬件实现层面，多线程的范围是一个 warp。所属与不同 warp 的 thread，具有不同的访存行为和控制流，是非常正常的事情，这就好像两个 CPU 进程有不同行为一样正常。而在同一个 warp 内的 thread，如果希望有不同的访存行为和控制流，就需要借助 warp 内的 id 和 mask 了。